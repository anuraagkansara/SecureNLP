There O
are O
two O
types O
of O
Derusbi O
malware O
: O
a O
client O
- O
server O
model O
and O
a O
server O
- O
client O
model O
. O
 
Both O
types O
provide O
basic O
RAT O
functionality O
with O
the O
distinction O
between O
the O
two O
being O
largely O
the O
directionality O
of O
the O
communication O
. O
 
This O
report O
will O
focus O
on O
the O
server O
- O
client O
variant O
( O
or O
simply O
, O
the O
" O
server O
variant O
" O
) O
of O
Derusbi B-Entity
, O
which O
acts O
as O
a O
server O
on O
a O
victim O
's O
machine O
and O
waits B-Action
for B-Modifier
commands O
from B-Entity
a I-Entity
controlling I-Entity
client I-Entity
. O
 
In O
and O
of O
itself O
, O
the O
Derusbi O
server O
variant O
is O
a O
largely O
unremarkable O
RAT O
when O
viewed O
from O
the O
perspective O
of O
functional O
capabilities O
. O
 
The O
server O
variant O
supports O
basic O
RAT O
functionality O
such O
as O
file O
management O
( O
uploading O
and O
downloading O
) O
, O
network O
tunneling O
and O
remote O
command O
shell O
. O
 
What O
makes O
the O
server O
variant O
interesting O
is O
the B-Entity
device I-Entity
driver I-Entity
that O
the B-Entity
variant I-Entity
installs B-Action
. O
 
The O
server B-Entity
variant I-Entity
utilizes O
a O
device O
driver O
in O
order O
to O
hook B-Action
into B-Modifier
the O
Windows B-Entity
firewall I-Entity
by O
either O
using O
largely O
undocumented O
Windows O
Firewall O
hooking O
techniques O
found O
in O
Windows O
XP O
and O
older O
or O
by O
using O
the O
documented O
Windows O
Filtering O
Platform O
found O
in O
Windows O
Vista O
and O
later O
. O
 
The O
driver B-Entity
, O
after O
hooking B-Action
the O
firewall B-Entity
using O
either O
of O
the O
two O
mentioned O
interfaces O
, O
will O
inspect O
incoming O
network O
packets O
. O
 
If O
a O
specific O
handshake O
occurs O
between O
the O
client O
and O
the O
server O
variant O
, O
the O
remainder O
of O
the O
communication O
session O
for O
the O
established O
session O
will O
be O
redirected O
to O
the O
server O
variant O
. O
 
If O
the O
driver O
does O
not O
detect O
the O
appropriate O
handshake O
, O
then O
the O
network O
traffic O
is O
allowed O
to O
pass O
unobstructed O
. O
 
This O
allows O
an B-Entity
attacker I-Entity
to O
hide B-Action
their O
communication B-Entity
within O
a O
cluster O
of O
network O
sessions O
originating O
from O
a O
single O
IP O
such O
as O
would O
be O
the O
case O
for O
a O
client O
performing O
multiple O
HTTP O
requests O
against O
a O
web O
server O
. O
 
The O
server O
variant O
runs O
as O
a O
svchost O
dependent O
service O
. O
 
While O
the O
server O
variant O
binary O
does O
have O
exports O
related O
to O
the O
standard O
service O
DLL O
( O
e.g. O
 
ServiceMain O
, O
DllRegisterService O
, O
etc O
. O
) O
, O
the O
startup O
sequence O
truly O
begins O
in O
the O
DllEntryPoint O
function O
. O
 
When O
loaded B-Action
into B-Modifier
memory B-Entity
via B-Modifier
a O
LoadLibrary B-Entity
or I-Entity
equivalent I-Entity
function I-Entity
call I-Entity
, O
the B-Entity
server I-Entity
variant I-Entity
will O
determine O
the O
name O
of O
the O
host O
binary O
( O
presumably O
svchost.exe O
) O
as O
well O
as O
its O
own O
DLL O
's O
name O
. O
 
The O
binary B-Entity
then O
spawns B-Action
a O
new B-Entity
thread I-Entity
that O
contains O
the O
main O
server O
variant O
code O
in O
order O
to O
allow O
the O
DllEntryPoint O
routine O
to O
return O
to O
the O
calling O
function O
. O
 
Within O
the O
main O
server O
variant O
function O
( O
dubbed O
mainThread O
) O
, O
the O
server O
variant O
loads O
a O
pointer O
to O
the O
API O
function O
GetCommandLineW O
, O
locates O
the O
pointer O
in O
memory O
to O
the O
command O
line O
string O
, O
and O
then O
locates O
the O
first O
space O
within O
the O
command O
line O
string O
and O
terminates O
the O
string O
by O
placing O
a O
NULL O
character O
at O
the O
location O
. O
 
The O
server B-Entity
variant I-Entity
then O
attempts O
to O
determine B-Action
if B-Modifier
it O
has B-Entity
suitable I-Entity
access I-Entity
rights I-Entity
within O
the O
system O
in O
order O
to O
operation O
. O
 
The O
check B-Entity
for I-Entity
access I-Entity
rights I-Entity
effectively O
checks B-Action
to O
see O
if B-Modifier
the O
server B-Entity
variant I-Entity
process I-Entity
is I-Entity
running I-Entity
under I-Entity
the I-Entity
NT I-Entity
Authority I-Entity
. O
 
If O
the O
check O
is O
unsuccessful O
, O
then O
the O
server O
variant O
terminates O
. O
 
With O
the O
command O
line O
patched O
and O
authority O
verified O
, O
the O
server O
variant O
sleeps O
for O
5 O
seconds O
before O
verifying O
that O
the O
fShutdown O
flag O
is O
not O
set O
. O
 
The O
fShutdown O
flag O
can O
become O
set O
by O
the O
process O
loading O
the O
server O
variant O
calling O
the O
DllRegisterServer O
export O
. O
 
The O
DllRegisterServer B-Entity
function I-Entity
, O
among O
other O
tasks O
, O
will O
attempt O
to O
install B-Action
the O
server B-Entity
variant I-Entity
as O
a O
server O
on O
the O
victim O
's O
machine O
. O
 
Therefore O
, O
by O
waiting O
5 O
seconds O
before O
continuing O
the O
mainThread O
functionality O
, O
the O
server O
variant O
is O
giving O
the O
DllRegisterServer O
time O
to O
activate O
and O
perform O
the O
necessary O
operations O
to O
ensure O
that O
the O
server O
variant O
is O
properly O
installed O
and O
activated O
as O
a O
service O
. O
 
The O
mainThread O
calls O
the O
mainLoop O
function O
of O
the O
server O
variant O
. O
 
The O
mainLoop B-Entity
function I-Entity
begins O
by O
loading B-Action
the O
unique B-Entity
infection I-Entity
ID I-Entity
for O
the O
victim O
's O
machine O
from O
the O
registry O
( O
under O
the O
key O
value O
located O
at O
HKLM\SOFTWARE\Microsoft\Rpc\Security O
) O
. O
 
The O
infection O
ID O
, O
if O
present O
, O
must O
be O
decoded O
by O
XOR'ing O
each O
byte O
of O
the O
string O
with O
a O
static O
byte O
value O
( O
typically O
0x5F O
) O
. O
 
If O
the O
infection O
ID O
does O
not O
exist O
within O
the O
registry O
, O
the O
server O
variant O
will O
attempt O
to O
load O
the O
configuration O
from O
an O
encoded O
buffer O
located O
immediately O
after O
the O
static O
string O
XXXXXXXXXXXXXXX O
, O
decode O
the O
buffer O
by O
starting O
at O
the O
last O
byte O
and O
XORing O
each O
previous O
byte O
by O
the O
current O
byte O
value O
in O
reverse O
order O
; O
the O
server O
variant O
will O
then O
use O
a O
specific O
portion O
of O
the O
configuration O
blob O
as O
the O
infection O
ID O
's O
base O
. O
 
Next O
, O
the O
server O
variant O
will O
append O
a O
hyphen O
and O
a O
four O
digit O
value O
to O
the O
end O
of O
the O
infection O
ID O
to O
generate O
the O
unique O
infection O
ID O
for O
the O
victim O
's O
machine O
. O
 
The O
newly O
generated O
infection O
ID O
is O
then O
saved O
to O
the O
registry O
location O
stated O
previously O
. O
 
The O
mainLoop B-Entity
attempts O
to O
get B-Action
the O
privileges B-Entity
for O
SeDebugPrivilege O
, O
SeLoadDriverPrivilege O
, O
SeShutdownPrivilege O
, O
and O
SeTcbPrivilege O
in O
order O
to O
perform O
the O
necessary O
operations O
to O
load O
the O
driver O
portion O
of O
the O
server O
variant O
. O
 
The O
mainLoop O
will O
attempt O
to O
open O
a O
handle O
to O
the O
driver O
( O
if O
it O
is O
already O
installed O
) O
by O
calling O
CreateFile O
with O
the O
filename O
of O
\Device\{93144EB0 O
- O
8E3E-4591-B307 O
- O
8EEBFE7DB28F}. O
 
Failing O
this O
, O
the O
mainLoop O
determines O
if O
the O
victim O
's O
machine O
is O
running O
the O
360 O
antivirus O
product O
by O
looking O
for O
a O
process O
with O
the O
name O
ZhuDongFangYu.exe O
. O
 
If O
the O
process O
is O
running O
, O
the O
driver O
is O
not O
installed O
but O
the O
mainLoop O
continues O
regardless O
. O
 
If O
the O
process O
is O
not O
found O
, O
however O
, O
the O
mainLoop O
will O
extract O
the O
driver O
binary O
from O
an O
encoded O
buffer O
within O
itself O
, O
decode O
the O
file O
in O
memory O
( O
using O
a O
rotating O
4-byte O
XOR O
key O
) O
, O
and O
install O
the O
driver O
on O
the O
victim O
's O
machine O
as O
% O
SYSDIR%\Drivers\{93144EB0 O
- O
8E3E-4591-B307 O
- O
8EEBFE7DB28F}.sys O
. O
 
With O
the O
driver O
present O
( O
or O
recently O
installed O
) O
, O
the O
mainLoop O
spawns O
another O
thread O
( O
dubbed O
DerusbiThread::DerusbiThread O
) O
that O
acts O
as O
the O
primary O
communication O
loop O
. O
 
DerusbiThread::DerusbiThread O
begins O
by O
generating O
a O
PCC_SOCK O
object O
. O
 
PCC_SOCK O
is O
an O
abstraction O
for O
the O
communication O
subsystem O
. O
 
The O
prototype O
for O
PCC_SOCK O
appears O
in O
Figure O
1 O
. O
 
With O
a O
new O
PCC_SOCK O
object O
allocates O
, O
DerusbiThread::DerusbiThread B-Entity
selects B-Action
a O
port B-Entity
between I-Entity
40,000 I-Entity
and I-Entity
45,000 I-Entity
to B-Modifier
use O
as B-Entity
a I-Entity
listening I-Entity
port I-Entity
. O
 
The O
port O
number O
is O
sent O
to O
the O
driver O
( O
via O
IOCTL O
0x220200 O
) O
in O
order O
to O
inform O
the O
driver O
where O
to O
redirect O
incoming O
traffic O
. O
 
The O
" O
Windows O
Device O
Driver O
( O
Firewall O
Hook O
) O
" O
section O
explains O
the O
functionality O
of O
the O
driver O
in O
greater O
detail O
. O
 
DerusbiThread::DerusbiThread B-Entity
binds O
to O
the O
specified O
port O
and O
opens B-Action
the O
port B-Entity
as B-Modifier
a O
listener B-Entity
. O
 
At O
this O
point O
DerusbiThread::DerusbiThread O
enters O
an O
infinite O
loop O
of O
waiting O
for O
new O
connections O
to O
the O
listening O
socket O
and O
dispatching O
a O
new O
thread O
( O
dubbed O
CommLoop O
) O
to O
handle O
the O
traffic O
for O
the O
socket O
until O
fShutdown O
is O
set O
. O
 
At O
this O
point O
, O
the O
startup O
sequence O
for O
Derusbi O
is O
complete O
and O
the O
server O
variant O
moves O
into O
a O
communication O
and O
command O
dispatch O
phase O
. O
 
The O
communication O
between O
the O
controlling O
client O
and O
the O
Derusbi O
server O
variant O
depends O
on O
the O
device O
driver O
being O
in O
place O
. O
 
The O
authors O
of O
the O
device O
driver O
designed O
the O
driver O
to O
work O
on O
Windows O
2000 O
and O
later O
versions O
of O
the O
Windows O
operating O
system O
. O
 
Depending O
on O
the O
version O
of O
the O
victim O
's O
OS O
, O
the O
driver O
will O
hook O
the O
Windows O
Firewall O
by O
either O
using O
the O
surprisingly O
undocumented O
IOCTL_IP_SET_FIREWALL_HOOK O
command O
of O
the O
\\Device\IP O
device O
for O
Windows O
XP O
or O
older O
machines O
or O
by O
using O
the O
documented O
Windows O
Filtering O
Platform O
( O
WFP O
) O
found O
in O
Windows O
Vista O
and O
later O
. O
 
The O
device B-Entity
driver I-Entity
inspects B-Action
incoming O
network B-Entity
traffic I-Entity
from I-Entity
any I-Entity
client I-Entity
connecting I-Entity
to I-Entity
the I-Entity
victim I-Entity
machine I-Entity
, O
determines O
if O
an O
appropriate O
handshake O
packet O
occurs O
at O
the O
beginning O
of O
a O
new O
TCP O
session O
, O
and O
then O
makes O
the O
decision O
to O
reroute B-Action
the O
network B-Entity
traffic I-Entity
to O
the O
Derusbi O
malware O
or O
let O
the O
traffic O
continue O
unaltered O
to O
its O
original O
service O
. O
 
Once O
a O
session O
has O
been O
established O
by O
means O
of O
a O
valid O
handshake O
, O
any O
subsequent O
packets O
from O
the O
client O
for O
the O
given O
TCP O
session O
will O
automatically O
be O
directed O
by O
the O
device O
driver O
to O
the O
Derusbi O
server O
variant O
. O
 
The O
device O
driver O
does O
not O
capture O
or O
store O
any O
network O
traffic O
outside O
of O
the O
initial O
handshake O
inspection O
. O
 
The O
Derusbi B-Entity
server I-Entity
variant I-Entity
will O
select O
an B-Entity
available I-Entity
, I-Entity
random I-Entity
port I-Entity
between O
the O
range O
of O
40,000 O
and O
45,000 O
on O
the O
victim O
's O
machine O
upon O
which O
to O
listen B-Action
. O
 
After O
selecting O
the O
port O
, O
the O
server O
variant O
will O
wait O
for O
incoming O
connections O
and O
instruct O
the B-Entity
driver I-Entity
to O
redirect B-Action
appropriate O
TCP B-Entity
sessions I-Entity
to O
the O
listening O
port O
. O
 
In O
order O
to O
establish O
a O
valid O
communication O
channel O
between O
the O
server O
variant O
and O
a O
controlling O
client O
, O
a O
specific O
handshake O
is O
required O
. O
 
The O
handshake O
between O
a O
client O
and O
the O
server O
variant O
is O
well O
defined O
and O
consisting O
of O
64 O
bytes O
, O
the O
data O
within O
the O
handshake O
is O
entirely O
random O
with O
the O
exception O
of O
the O
3rd O
and O
8th O
DWORD O
. O
 
The O
handshake O
begins O
when O
the O
client O
sends O
a O
64 O
byte O
random O
buffer O
with O
the O
3rd O
( O
offset O
12 O
) O
and O
8th O
( O
offset O
32 O
) O
DWORDs O
defined O
as O
. O
 
The O
server O
will O
acknowledge O
the O
handshake O
by O
sending O
a O
64 O
byte O
random O
buffer O
with O
the O
same O
pattern O
for O
the O
3rd O
and O
8th O
DWORDs O
based O
on O
the O
new O
, O
randomly O
generated O
1st O
DWORD O
( O
offset O
0 O
) O
. O
 
It O
is O
the O
client O
's O
handshake O
that O
the O
driver O
for O
the O
server O
variant O
triggers O
off O
of O
. O
 
Some O
older O
versions O
of O
the O
server O
variant O
use O
a O
different O
set O
of O
DWORDs O
to O
validate O
the O
handshake O
, O
also O
the O
tests O
are O
the O
same O
. O
 
These O
other O
versions O
have O
been O
observed O
to O
use O
the O
following O
DWORDs O
. O
 
If O
the O
handshake O
fails O
, O
the O
server O
variant O
provides O
a O
secondary O
means O
to O
authenticate O
a O
client O
. O
 
Presumably O
a O
failsafe O
if O
the O
driver O
is O
unable O
to O
load O
, O
the O
secondary O
method O
requires O
the O
client O
to O
send O
a O
POST O
request O
with O
the O
following O
form O
. O
 
In O
addition O
, O
the O
POST O
request O
must O
contain O
a O
Via O
field O
. O
 
If O
the O
request O
and O
the O
Via O
field O
exist O
, O
the O
server O
variant O
authenticates O
the O
client O
and O
responds O
with O
If O
the O
client O
's O
request O
does O
not O
meet O
the O
appropriate O
authentication O
criteria O
, O
the O
server O
variant O
sends O
. O
 
With O
a O
communication O
channel O
between O
the O
server O
variant O
and O
the O
client O
established O
, O
the O
server O
sends O
information O
about O
the O
victim O
's O
computer O
. O
 
Consisting O
of O
a O
180 O
byte O
data O
structure O
( O
Figure O
3 O
) O
, O
the O
server O
variant O
provides O
the O
client O
with O
a O
variety O
of O
details O
about O
the O
victim O
's O
machine O
. O
 
The O
VictimInfoPacket O
has O
an O
identifier O
of O
2 O
( O
see O
the O
dwPktType O
explanation O
below O
) O
. O
 
The O
communication O
between O
the O
server O
and O
the O
client O
at O
this O
point O
, O
and O
for O
the O
remainder O
of O
the O
session O
, O
is O
encrypted O
. O
 
Communication O
between O
the O
client O
and O
the O
server O
variant O
exists O
in O
the O
form O
of O
a O
sequence O
of O
encrypted O
datagrams O
. O
 
Each O
datagram O
consists O
of O
a O
24 O
byte O
header O
followed O
by O
an O
optional O
payload O
section O
. O
 
The O
header O
is O
not O
encrypted O
but O
if O
the O
optional O
payload O
is O
attached O
, O
the O
payload O
is O
encrypted O
using O
a O
DWORD O
XOR O
. O
 
The O
format O
of O
the O
header O
is O
as O
follows O
. O
 
The O
dwTotalPacketSize O
field O
defines O
the O
total O
size O
of O
the O
datagram O
including O
both O
the O
size O
of O
the O
header O
and O
the O
size O
of O
the O
optional O
payload O
. O
 
The O
dwPktType O
field O
correlates O
to O
the O
module O
ID O
which O
allows O
the O
server O
variant O
to O
route O
the O
datagram O
to O
the O
appropriate O
module O
without O
further O
inspection O
of O
the O
payload O
data O
. O
 
The O
dwChecksum O
value O
is O
sum O
of O
all O
of O
the O
bytes O
within O
the O
optional O
header O
( O
the O
field O
is O
ignored O
, O
but O
present O
, O
if O
there O
is O
no O
payload O
section O
) O
. O
 
The O
dwEncryptionKey O
is O
the O
32-bit O
XOR O
encryption O
key O
for O
the O
payload O
section O
. O
 
If O
the O
fCompressedPayload O
field O
is O
non O
- O
zero O
, O
then O
the O
data O
within O
the O
payload O
is O
compressed O
using O
LZO O
compression O
( O
prior O
to O
XOR O
encoding O
) O
and O
the O
dwDecompressedSize O
field O
represents O
the O
final O
size O
of O
the O
payload O
data O
after O
decompression O
. O
 
The O
payload O
section O
can O
have O
up O
to O
three O
different O
presentations O
depending O
on O
if O
compression O
is O
used O
. O
 
The O
first O
presentation O
is O
the O
original O
payload O
data O
as O
generated O
by O
the O
client O
or O
server O
, O
the O
second O
presentation O
is O
the O
LZO O
compressed O
form O
, O
and O
the O
final O
presentation O
( O
the O
presentation O
that O
exists O
going O
across O
the O
network O
) O
is O
the O
32-bit O
XOR O
encoded O
data O
blob O
. O
 
Figure O
4 O
provides O
a O
graphical O
representation O
of O
the O
presentation O
types O
of O
the O
payload O
section O
. O
 
After O
sending B-Action
the O
server B-Entity
information I-Entity
via O
the O
VictimInfoPacket O
, O
the B-Entity
server I-Entity
variant O
spins O
off O
a O
CommLoop O
thread O
for O
the O
connection O
and O
returns O
to O
waiting O
for O
new O
connections O
from O
clients O
to O
appear O
. O
 
The O
CommLoop O
thread O
begins O
by O
establishing O
the O
set O
of O
internal O
command O
handlers O
available O
to O
the O
server O
variant O
. O
 
With O
the O
exception O
of O
the O
administrative O
command O
handler O
( O
which O
is O
built O
into O
the O
CommLoop O
) O
, O
each O
of O
the O
internal O
commands O
consists O
of O
an O
object O
derived O
from O
a O
base O
object O
PCC_BASEMOD O
. O
 
The O
server O
variant O
appears O
to O
have O
a O
modular O
design O
allowing O
an O
attacker O
to O
compile O
only O
the O
components O
that O
are O
necessary O
for O
any O
given O
operation O
. O
 
The O
malware O
supports O
up O
to O
8 O
different O
modules O
per O
sample O
with O
each O
module O
designating O
its O
own O
ID O
code O
. O
 
Novetta O
has O
observed O
the O
following O
modules O
. O
 
Given O
the O
spacing O
in O
ID O
numbers O
( O
as O
noted O
in O
the O
gap O
between O
0x82 O
and O
0x84 O
in O
an O
otherwise O
sequential O
ID O
scheme O
) O
, O
it O
is O
conceivable O
that O
additional O
modules O
exist O
. O
 
After O
establishing O
the O
tools O
, O
an O
infinite O
loop O
( O
CommLoop O
) O
is O
entered O
in O
which O
the O
server O
variant O
will O
wait O
for O
up O
to O
1/100 O
of O
a O
second O
for O
input O
from O
the O
network O
; O
if O
such O
input O
arrives O
, O
the O
server O
routes O
the O
packet O
to O
the O
appropriate O
handler O
. O
 
If O
the O
network O
input O
does O
not O
arrive O
, O
the O
CommLoop O
queries O
each O
of O
the O
command O
handlers O
for O
any O
packets O
they O
may O
have O
queued O
( O
by O
calling O
each O
command O
handler O
's O
ReadWaitingData O
function O
) O
and O
transmits O
the O
packets O
the O
handlers O
have O
generated O
. O
 
Additionally O
, O
if O
more O
than O
60 O
seconds O
passes O
between O
network O
inputs O
from O
the O
client O
or O
network O
outputs O
from O
the O
server O
variant O
, O
the O
CommLoop O
will O
send O
out O
a O
beacon O
packet O
( O
dwPktType O
= O
4 O
) O
. O
 
CommLoop B-Entity
routes B-Action
packets B-Entity
to B-Modifier
the O
appropriate B-Entity
command I-Entity
handler I-Entity
object I-Entity
by O
locating O
the O
dwPacketIdentifierCode O
within O
each O
of O
the O
registered O
command O
handlers O
that O
matches O
the O
incoming O
packets O
dwPktType O
. O
 
When O
the O
appropriate O
command O
handler O
is O
found O
, O
CommLoop O
passes O
the O
payload O
of O
portion O
of O
the O
packet O
to O
the O
command O
handler O
's O
ProcessPacket O
function O
. O
 
The O
PCC_CMD O
object O
contains O
the O
remote O
shell O
functionality O
of O
the O
server O
variant O
along O
with O
the O
ability O
to O
execute O
arbitrary O
programs O
. O
 
Derived O
from O
the O
PCC_BASEMOD O
class O
, O
the O
PCC_CMD O
class O
's O
operations O
are O
focused O
largely O
in O
the O
ProcessPacket O
and O
ReadWaitingData O
functions O
. O
 
The O
PCC_CMD::ProcessPacket O
function O
works O
as O
a O
stub O
function O
that O
merely O
passes O
the O
packet O
's O
payload O
data O
( O
pkt O
) O
data O
to O
PCC_CMD::ProcessPacketEx O
while O
ignoring O
the O
dwPktSize O
parameter O
. O
 
The O
packet O
's O
payload O
data O
is O
, O
in O
and O
of O
itself O
, O
another O
datagram O
with O
a O
header O
and O
optional O
payload O
section O
. O
 
The O
payload O
of O
each O
PCC_CMD O
destined O
packet O
contains O
the O
following O
header O
. O
 
The O
dwCommandType O
field O
specifies O
the O
specific O
PCC_CMD O
command O
that O
the O
client O
is O
requesting O
the O
server O
variant O
perform O
. O
 
There O
are O
four O
commands O
that O
PCC_CMD O
supports O
. O
 
For O
each O
of O
the O
commands O
, O
any O
output O
from O
or O
acknowledgement O
of O
the O
commands O
comes O
in O
the O
form O
of O
another O
packet O
consisting O
of O
a O
PacketHeader O
followed O
by O
a O
PCCCMDPacketHeader O
and O
any O
optional O
payload O
data O
. O
 
The O
dwCommandType O
of O
the O
newly O
constructed O
packet O
matches O
the O
command O
's O
original O
dwCommandType O
value O
( O
e.g. O
 
responses O
from O
0x04 O
commands O
will O
reply O
with O
dwCommandType O
set O
to O
0x04 O
) O
. O
 
PCC_CMD::ProcessPacketEx O
will O
queue O
the O
response O
packets O
in O
an O
internal O
buffer O
. O
 
The O
PCC_CMD::ReadWaitingData O
member O
function O
is O
responsible O
for O
transmitting O
any O
of O
the O
previously O
queued O
packets O
from O
PCC_CMD::ProcessPacketEx O
. O
 
If O
there O
are O
no O
queued O
packets O
, O
PCC_CMD::ReadWaitingData O
will O
perform O
a O
queue O
of O
the O
console O
output O
pipe O
for O
the O
remote O
shell O
process O
( O
if O
it O
is O
active O
) O
; O
the O
function O
will O
also O
attempt O
to O
read O
the O
entirety O
of O
the O
waiting O
data O
, O
which O
then O
becomes O
the O
payload O
of O
a O
PacketHeader O
/ O
PCCCMDPacketHeader O
based O
packet O
with O
the O
dwCommandType O
set O
to O
0x0C. O
 
If O
the O
read O
is O
unsuccessful O
, O
the O
function O
returns O
a O
PacketHeader O
/ O
PCCCMDPacketHeader O
based O
packet O
with O
the O
dwCommandType O
set O
to O
0x10 O
indicating O
an O
error O
and O
terminating O
the O
remote O
shell O
session O
. O
 
The O
PCC_FILE O
object O
provides O
a O
large O
range O
of O
file O
system O
administration O
functions O
. O
 
PCC_FILE O
is O
derived O
from O
the O
PCC_BASEMOD O
class O
meaning O
that O
the O
processing O
of O
commands O
should O
be O
contained O
within O
the O
PCC_FILE::ProcessPacket O
member O
function O
with O
some O
additional O
processing O
done O
in O
the O
PCC_FILE::ReadWaitingData O
member O
function O
. O
 
This O
is O
not O
necessarily O
the O
case O
, O
however O
. O
 
The O
PCC_FILE::ProcessPacket O
member O
function O
, O
much O
like O
PCC_CMD::ProcessPacket O
, O
is O
little O
more O
than O
a O
stub O
function O
that O
passes O
only O
a O
copy O
of O
the O
payload O
data O
( O
pkt O
) O
to O
PCC_FILE::ProcessPacketEx O
. O
 
PCC_FILE::ProcessPacketEx O
performs O
no O
file O
management O
operations O
but O
instead O
adds O
any O
incoming O
command O
packets O
to O
a O
queue O
for O
processing O
by O
PCC_FILE::ReadWaitingData O
if O
the O
packet O
is O
not O
already O
within O
the O
queue O
( O
thus O
avoiding O
duplication O
of O
commands O
) O
. O
 
The O
PCC_FILE::ReadWaitingData O
member O
function O
is O
a O
stub O
function O
that O
calls O
PCC_FILE::ProcessQueue O
and O
returns O
the O
resulting O
packet O
from O
the O
queue O
processing O
. O
 
This O
means O
that O
file O
operations O
are O
surprisingly O
low O
priority O
, O
and O
potentially O
, O
high O
latency O
operations O
. O
 
Each O
packet O
that O
arrives O
within O
the O
packet O
queue O
of O
PCC_FILE O
contains O
a O
standard O
header O
followed O
by O
a O
( O
quasi O
- O
optional O
) O
payload O
data O
blob O
. O
 
The O
header O
for O
the O
PCC_FILE O
command O
packets O
takes O
the O
following O
form O
. O
 
The O
dwCommandType O
field O
specifies O
the O
specific O
PCC_FILE O
command O
that O
the O
client O
is O
requesting O
the O
server O
variant O
to O
perform O
. O
 
PCC_FILE O
supports O
17 O
( O
of O
which O
15 O
are O
unique O
) O
commands O
. O
 
While O
the O
general O
form O
within O
the O
Derusbi O
server O
variant O
communication O
model O
is O
to O
return O
a O
packet O
with O
the O
same O
dwCommandType O
as O
the O
original O
command O
, O
many O
of O
the O
PCC_FILE O
commands O
return O
a O
status O
packet O
type O
( O
dwCommandType O
= O
0x04 O
) O
. O
 
Commands O
0x2C O
, O
0x44 O
, O
and O
0x48 O
all O
appear O
to O
be O
the O
exact O
same O
base O
command O
with O
only O
slight O
variations O
in O
their O
response O
format O
. O
 
It O
is O
unclear O
why O
this O
particular O
command O
is O
included O
three O
times O
in O
PCC_FILE O
. O
 
The O
PCC_PROXY O
object O
provides O
the O
platform O
for O
a O
tunneling O
network O
traffic O
to O
and O
from O
the O
client O
to O
a O
specific O
endpoint O
( O
or O
endpoints O
if O
multiple O
tunnels O
are O
activated O
by O
the O
client O
) O
. O
 
Derived O
on O
the O
PCC_BASEMOD O
class O
, O
the O
PCC_PROXY O
class O
performs O
very O
little O
network O
tunneling O
within O
the O
CommLoop O
interactive O
PCC_PROXY::ProcessPacket O
and O
PCC_PROXY::ReadWaitingData O
member O
functions O
. O
 
The O
PCC_PROXY::ProcessPacket O
member O
function O
queues O
incoming O
PCC_PROXY O
packets O
into O
a O
received O
queue O
while O
PCC_PROXY::ReadWaitingData O
returns O
packets O
from O
a O
transmit O
queue O
, O
with O
the O
directionality O
from O
the O
perspective O
of O
the O
server O
variant O
. O
 
The O
core O
of O
the O
PCC_PROXY O
's O
network O
tunneling O
comes O
from O
a O
spawned O
processing O
thread O
( O
PCC_PROXY::MainThread O
) O
that O
is O
generated O
when O
the O
PCC_PROXY O
object O
is O
instantiated O
. O
 
The O
PCC_PROXY::MainThread O
function O
consist O
an O
infinite O
loop O
that O
only O
terminates O
when O
the O
PCC_PROXY::fShutdown O
flag O
is O
set O
. O
 
Otherwise O
, O
the O
loop O
will O
inspect O
another O
internal O
flag O
( O
PCC_PROXY::fNetworkEnabled O
) O
to O
determine O
if O
the O
network O
tunneling O
is O
currently O
active O
. O
 
If O
the O
PCC_PROXY::fNetworkEnabled O
flag O
is O
set O
to O
false O
, O
then O
tunneling O
is O
disabled O
but O
command O
processing O
continues O
. O
 
It O
is O
possible O
to O
have O
more O
than O
one O
tunnel O
active O
at O
any O
given O
time O
. O
 
In O
order O
to O
firewall O
tunnels O
from O
each O
other O
over O
the O
backbone O
of O
the O
server O
variant O
's O
command O
channel O
, O
each O
tunnel O
is O
assigned O
a O
specific O
channel O
identifier O
. O
 
This O
allows O
the O
client O
to O
specify O
which O
specific O
tunnel O
data O
is O
transmitted O
to O
as O
well O
as O
telling O
the O
client O
which O
tunnel O
is O
returning O
data O
. O
 
If O
the O
PCC_PROXY::fNetworkEnabled O
flag O
is O
set O
to O
true O
, O
PRC_PROXY::MainThread O
will O
loop O
through O
all O
active O
channels O
, O
perform O
a O
select O
on O
the O
socket O
connected O
to O
the O
endpoint O
and O
-- O
if O
the O
select O
indicates O
that O
there O
is O
data O
waiting O
on O
a O
particular O
socket O
-- O
the O
data O
is O
read O
. O
 
A O
new O
PCC_PROXY O
based O
packet O
is O
then O
generated O
and O
the O
packet O
is O
queued O
for O
delivery O
to O
the O
client O
. O
 
After O
processing O
each O
of O
the O
channels O
for O
new O
data O
, O
PCC_PROXY::MainThread O
processes O
incoming O
command O
packets O
from O
the O
client O
( O
an O
operation O
usually O
handled O
by O
the O
PCC_BASEMOD::ProcessPacket O
function O
) O
. O
 
Packets O
belonging O
to O
the O
PCC_PROXY O
subsystem O
have O
a O
common O
header O
, O
much O
like O
the O
other O
PCC_BASEMOD O
derived O
classes O
. O
 
To O
this O
end O
, O
the O
PCC_PROXY O
packets O
have O
the O
same O
packet O
header O
as O
the O
PCCFilePacketHeader O
packet O
header O
. O
 
The O
PCC_PROXY O
supports O
five O
commands O
. O
 
The O
administrative O
commands O
are O
built O
- O
in O
to O
the O
server O
variant O
and O
are O
not O
derived O
from O
the O
PCC_BASEMOD O
class O
. O
 
Each O
of O
the O
administrative O
command O
packets O
contains O
the O
same O
header O
structure O
as O
the O
PCCFilePacketHeader O
structure O
followed O
by O
an O
optional O
payload O
data O
blob O
. O
 
The O
administrative O
commands O
consist O
of O
the O
following O
five O
commands O
. O
 
Given O
the O
encrypted O
, O
and O
potentially O
compressed O
, O
nature O
of O
Derusbi O
server O
variant O
network O
traffic O
, O
detecting O
the O
traffic O
on O
a O
network O
can O
be O
problematic O
using O
traditional O
IDS O
signatures O
. O
 
Using O
a O
heuristic O
approach O
, O
it O
would O
be O
possible O
to O
detect O
the O
handshake O
of O
a O
possible O
Derusbi O
server O
variant O
session O
by O
looking O
for O
the O
following O
pattern O
. O
 
Detecting O
Derusbi O
server O
variants O
on O
disk O
is O
possible O
using O
the O
following O
YARA O
signature O
. O
 
