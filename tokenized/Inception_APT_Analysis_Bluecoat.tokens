After O
reading O
the O
Inception O
paper O
by O
Snorre O
Fagerland O
and O
Waylon O
Grange O
, O
I O
got O
curious O
about O
this O
threat O
and O
did O
some O
reversing O
. O
 
I O
felt O
that O
it O
would O
be O
good O
to O
write O
a O
technical O
blog O
about O
the O
process O
- O
maybe O
it O
could O
be O
helpful O
or O
interesting O
for O
some O
. O
 
RTF O
file O
Analysis O
MD5 O
: O
4a4874fa5217a8523bf4d1954efb26ef O
Exploit O
: O
CVE-2012 O
- O
0158 O
As O
we O
can O
see O
in O
following O
screen O
shot O
, O
this O
is O
a O
RTF O
[ O
Rich O
Text O
Format O
] O
file O
. O
 
Its O
common O
that O
attackers O
use O
document O
files O
such O
as O
these O
as O
bait O
. O
 
It O
is O
common O
that O
shellcode O
starts O
with O
a O
NOPsled O
. O
 
In O
following O
screenshot O
we O
can O
see O
that O
the O
embedded O
shellcode O
starts O
with O
NOP O
slide O
. O
 
NOP O
, O
or O
No O
OPeration O
- O
is O
a O
single O
- O
byte O
opcode O
that O
does O
nothing O
. O
 
It O
has O
the O
hex O
value O
of O
0x90 O
. O
 
Now O
, O
to O
the O
functionality O
of O
the O
shellcode O
. O
 
We O
will O
ignore O
the O
first O
two O
prolog O
instructions O
, O
and O
for O
remaining O
statements O
I O
have O
inserted O
comments O
to O
help O
understanding O
what O
is O
happening O
in O
this O
chunk O
of O
code O
. O
 
It O
's O
traversing O
the O
TEB O
, O
the O
PEB O
and O
the O
Ldr O
structure O
to O
get O
the O
base O
addresses O
of O
ntdll.dll O
and O
kernel32.dll O
. O
 
It O
needs O
these O
to O
find O
the O
API O
addresses O
it O
requires O
for O
the O
rest O
of O
the O
infection O
. O
 
In O
screenshot O
below O
, O
Function O
00120F82 O
is O
the O
malware O
's O
own O
GetProcAddress O
function O
which O
takes O
two O
parameters O
The O
function O
returns O
the O
memory O
address O
of O
the O
API O
. O
 
As O
shown O
in O
the O
next O
screenshot O
, O
this O
function O
parses O
the O
" O
export O
name O
pointer O
table O
" O
of O
the O
.dll O
[ O
ex O
. O
 
kernel32.dll O
] O
and O
generates O
a O
hash O
for O
each O
function O
. O
 
It O
compares O
this O
with O
the O
argument O
API O
hash O
( O
Ex O
DF7D9BAD O
for O
GetFileSize O
, O
see O
above O
screenshot O
) O
using O
the O
CMP O
EDI O
, O
ESI O
instruction O
. O
 
Once O
the O
matching O
API O
is O
found O
it O
parses O
the O
Export O
Address O
Table O
and O
returns O
the O
respective O
API O
address O
to O
the O
caller O
in O
EAX O
register O
. O
 
The O
document O
contains O
two O
levels O
of O
shellcode O
. O
 
We O
are O
analyzing O
first O
level O
, O
and O
in O
the O
following O
code O
we O
can O
see O
a O
typical O
egghunting O
method O
: O
It O
attempts O
to O
open O
the O
already O
opened O
rtf O
file O
by O
checking O
file O
handles O
in O
memory O
. O
 
It O
starts O
with O
a O
handle O
with O
the O
value O
4 O
and O
verifies O
it O
by O
doing O
GetFileSize O
on O
it O
. O
 
If O
this O
fails O
it O
does O
ADD O
ESI,4 O
again O
( O
adds O
4 O
to O
the O
handle O
) O
until O
the O
API O
succeeds O
. O
 
When O
this O
happens O
it O
checks O
the O
file O
offset O
0x8300 O
for O
the O
marker O
0x54405450 O
. O
 
Again O
, O
if O
this O
matches O
up O
, O
it O
allocates O
memory O
into O
which O
it O
reads O
the O
file O
content O
and O
jumps O
to O
the O
2nd O
level O
shellcode O
with O
a O
JMP O
EBX O
. O
 
Now O
we O
have O
landed O
into O
the O
second O
level O
shellcode O
, O
but O
it B-Entity
is O
obfuscated B-Action
to B-Modifier
evade O
static B-Entity
analysis I-Entity
. O
 
At O
the O
initial O
stage O
there O
are O
few O
instructions O
waiting O
to O
help O
us O
. O
 
This O
is O
the O
deobfuscation O
code O
. O
 
We O
can O
see O
that O
0x23B O
* O
4 O
is O
the O
number O
of O
bytes O
obfuscated O
, O
POP O
EBX O
is O
the O
get O
EIP O
instruction O
and O
0x5687F945 O
is O
the O
deobfuscation O
XOR O
key O
. O
 
In O
following O
code O
we O
can O
see O
the O
hexadecimal O
value O
that O
corresponds O
to O
the O
library O
name O
being O
pushed O
to O
the O
LoadLibrary O
function O
, O
as O
well O
as O
two O
loops O
to O
get O
the O
API O
addresses O
using O
" O
CALL O
02E203E2 O
" O
function O
. O
 
Here O
also O
it O
uses O
hashes O
to O
look O
up O
APIs O
. O
 
In O
the O
following O
code O
it O
searches O
for O
the O
embedded O
VBS O
file O
inside O
the O
RTF O
file O
in O
memory O
. O
 
It O
checks O
for O
the O
file O
size O
in O
a O
loop O
, O
and O
if O
the O
size O
is O
larger O
than O
0x2000 O
then O
it O
sets O
the O
file O
ponter O
to O
0x8C14 O
to O
compare O
with O
the O
VBS O
file O
marker O
as O
we O
can O
see O
in O
following O
screenshot O
. O
 
After O
finding O
the O
VBS O
marker O
in O
memory O
, O
it O
decrypts O
the O
VBS O
file O
in O
two O
iterations O
. O
 
In O
the O
first O
loop O
it O
decrypts O
and O
in O
the O
second O
loop O
it O
swaps O
the O
low O
and O
high O
bytes O
of O
the O
first O
0x100 O
16-bit O
words O
, O
after O
which O
it O
writes O
the O
file O
to O
a O
file O
named O
" O
Temp O
/ O
ew_Rg.vbs O
" O
. O
 
The O
following O
screenshot O
shows O
a O
part O
of O
the O
.VBS O
payload O
file O
dropped O
by O
.RTF O
file O
. O
 
First O
line O
is O
the O
encrypted O
.dll O
4th O
line O
contains O
Key O
to O
decrypt O
the O
.dll O
. O
 
Remaining O
part O
is O
self O
- O
explanatory O
. O
 
The O
instruction O
c O
= O
Crypt(c O
, O
k O
) O
function O
decrypts O
the O
encrypted O
dll O
and O
returns O
the O
decrypted O
dll O
. O
 
( O
See O
the O
screenshot O
above O
) O
c= O
encrypted O
dll O
. O
 
k O
= O
decryption O
key O
. O
 
Following O
function O
writes O
byte O
by O
byte O
to O
the O
dropped.dll O
file O
. O
 
Finally O
, O
the O
following O
code O
executes O
the O
" O
regsvr32 O
" O
command O
to O
run O
the O
wmiprvse.dll O
in O
silent O
mode O
and O
sets O
the O
run O
key O
in O
registry O
. O
 
This O
first O
level O
of O
deobfuscation O
in O
wmiprvse.dll O
takes O
around O
3 O
- O
4 O
minutes O
to O
finish O
. O
 
Then O
it O
allocates O
memory O
using O
VirtualAlloc O
and O
writes O
the O
unpacked O
code O
to O
newly O
allocated O
memory O
before O
it O
jumps O
to O
the O
unpacked O
code O
as O
shown O
in O
following O
screen O
shot O
. O
 
This O
dll O
has O
3 O
layers O
of O
unpacking O
. O
 
The O
one O
above O
is O
level O
one O
, O
below O
iyou O
can O
see O
level O
two O
. O
 
We O
can O
see O
the O
passing O
of O
the O
control O
to O
the O
newly O
unpacked O
.dll O
@CALL O
EAX O
. O
 
It O
's O
very O
time O
- O
consuming O
to O
understand O
the O
functionality O
of O
the O
dll O
as O
it B-Entity
decrypts O
and O
builds B-Action
its O
own B-Entity
runtime I-Entity
import I-Entity
table I-Entity
to B-Modifier
hinder O
the B-Entity
analysis I-Entity
. O
 
Analyst O
can O
not O
directly O
see O
which O
API O
gets O
called O
. O
 
Finally O
we O
can O
see O
it B-Entity
's O
connecting B-Action
to B-Modifier
webdav.cloudme.com B-Entity
and O
cleartext O
credentials O
in O
following O
screenshot O
. O
 
Malware B-Entity
tries O
to O
communicate B-Action
with B-Modifier
the O
user B-Entity
account I-Entity
created I-Entity
at I-Entity
the I-Entity
WebDAV I-Entity
C&C I-Entity
to O
exfiltrate B-Action
system B-Entity
and O
user B-Entity
information I-Entity
. O
 
Reference O
. O
 
https://www.bluecoat.com O
/ O
security O
- O
blog/2014 O
- O
12 O
- O
09/blue O
- O
coat O
- O
exposes-%E2%80%9C- O
inception O
- O
framework%E2%80%9D O
- O
very O
- O
sophisticated O
- O
layered O
- O
malware O
 
