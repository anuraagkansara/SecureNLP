In O
October O
2011 O
, O
we O
analyzed O
a O
new O
threat O
what O
we O
named O
Duqu O
, O
and O
we O
showed O
that O
it O
has O
close O
relationships O
to O
the O
infamous O
Stuxnet O
attack O
. O
 
By O
courtesy O
of O
Kaspersky O
Lab O
, O
in O
late O
May O
2015 O
we O
received O
samples O
about O
a O
new O
threat O
, O
with O
the O
hint O
that O
it O
might O
be O
related O
to O
the O
Duqu O
attacks O
; O
however O
, O
these O
new O
samples O
are O
from O
2014 O
. O
 
We O
decided O
to O
carry O
out O
an O
individual O
research O
on O
the O
samples O
with O
the O
focus O
on O
the O
connections O
between O
the O
original O
Duqu O
attack O
and O
the O
new O
threat O
, O
dubbed O
" O
Duqu O
2.0 O
" O
. O
 
After O
analyzing O
the O
samples O
received O
, O
we O
think O
, O
that O
the O
adversaries O
behind O
Duqu O
malware O
are O
back O
and O
active O
; O
while O
they O
modified O
their O
tools O
to O
be O
undetected O
by O
old O
methods O
, O
they O
also O
strongly O
reused O
codes O
and O
ideas O
during O
their O
recent O
attacks O
. O
 
The O
numerous O
similarities O
that O
we O
discovered O
between O
Duqu O
and O
Duqu O
2.0 O
include O
the O
following O
. O
 
In O
this O
report O
, O
we O
present O
supporting O
details O
and O
analysis O
for O
all O
the O
similarities O
listed O
above O
. O
 
Stuxnet O
is O
probably O
the O
most O
well O
- O
known O
malware O
of O
our O
times O
. O
 
Its O
fame O
stems O
from O
the O
facts O
that O
it O
targeted O
a O
very O
specific O
industrial O
facility O
, O
namely O
a O
uranium O
enrichment O
plant O
in O
Iran O
, O
it O
aimed O
at O
physical O
destruction O
of O
uranium O
centrifuges O
, O
and O
it O
apparently O
accomplished O
its O
mission O
successfully O
. O
 
In O
addition O
to O
all O
these O
characteristics O
, O
IT O
security O
experts O
also O
appreciate O
its O
technical O
sophistication O
and O
the O
zero O
- O
day O
exploits O
that O
it O
used O
. O
 
Stuxnet O
was O
also O
an O
alarm O
to O
the O
developed O
world O
: O
it O
shed O
light O
on O
the O
capabilities O
of O
advanced O
attackers O
, O
and O
at O
the O
same O
time O
, O
on O
the O
numerous O
weaknesses O
of O
our O
computing O
infrastructure O
. O
 
Putting O
these O
two O
together O
, O
people O
started O
to O
feel O
hopelessly O
vulnerable O
. O
 
Yet O
, O
unfortunately O
, O
Stuxnet O
is O
not O
a O
unique O
example O
for O
a O
highly O
sophisticated O
targeted O
threat O
, O
but O
there O
are O
numerous O
other O
pieces O
of O
malware O
of O
similar O
kind O
, O
including O
Duqu O
, O
Flame O
, O
Regin O
, O
etc O
. O
 
Among O
those O
, O
Duqu O
is O
particularly O
interesting O
, O
not O
only O
because O
we O
discovered O
it O
back O
in O
2011 O
, O
but O
because O
our O
analysis O
pointed O
out O
that O
- O
while O
Duqu O
's O
objective O
is O
different O
- O
it O
has O
very O
strong O
similarities O
to O
Stuxnet O
in O
terms O
of O
architecture O
, O
code O
, O
and O
methods O
to O
achieve O
stealthiness O
. O
 
Today O
, O
it O
is O
widely O
believed O
within O
the O
IT O
security O
community O
that O
Duqu O
was O
created O
by O
the O
same O
attackers O
who O
created O
Stuxnet O
. O
 
And O
now O
we O
have O
a O
new O
member O
of O
the O
same O
family O
! O
Last O
month O
, O
we O
received O
interesting O
samples O
from O
Kaspersky O
Lab O
with O
a O
hint O
that O
they O
might O
be O
related O
to O
the O
Duqu O
samples O
of O
2011 O
; O
however O
, O
these O
new O
samples O
are O
from O
2014 O
. O
 
Our O
common O
understanding O
was O
that O
it O
would O
be O
interesting O
to O
figure O
out O
whether O
this O
new O
threat O
is O
indeed O
related O
to O
the O
old O
Duqu O
attack O
, O
and O
we O
in O
the O
CrySyS O
Lab O
should O
try O
to O
focus O
our O
analysis O
efforts O
on O
answering O
this O
question O
. O
 
It O
is O
important O
to O
emphasize O
that O
we O
did O
our O
analysis O
independently O
from O
Kaspersky O
Lab O
: O
we O
did O
not O
read O
their O
preliminary O
report O
and O
they O
did O
not O
share O
any O
of O
their O
findings O
with O
us O
( O
apart O
from O
the O
samples O
that O
we O
received O
from O
them O
) O
. O
 
The O
analysis O
results O
performed O
by O
Kaspersky O
Lab O
can O
be O
read O
in O
the O
following O
report O
. O
 
https://securelist.com O
/ O
blog O
/ O
research/70504/the O
- O
mystery O
- O
of O
- O
duqu- O
2 O
- O
0-a O
- O
sophisticated O
- O
cyberespionage O
- O
actor O
- O
returns/ O
In O
this O
report O
, O
we O
present O
the O
results O
of O
our O
comparative O
analysis O
of O
the O
old O
version O
of O
Duqu O
and O
the O
new O
version O
, O
codenamed O
" O
Duqu O
2.0 O
" O
. O
 
We O
concentrate O
on O
the O
description O
of O
the O
relevant O
similarities O
and O
differences O
we O
have O
found O
between O
the O
two O
malware O
samples O
. O
 
In O
the O
table O
below O
, O
one O
can O
see O
the O
MD5 O
fingerprints O
of O
the O
two O
samples O
we O
have O
examined O
during O
our O
initial O
analysis O
. O
 
The O
first O
module O
will O
be O
referenced O
in O
this O
document O
with O
the O
name O
" O
c7c647 O
" O
, O
and O
the O
second O
with O
the O
name O
" O
3f52ea O
" O
according O
to O
the O
prefix O
of O
their O
MD5 O
hashes O
. O
 
In O
the O
following O
chapter O
, O
we O
will O
discuss O
the O
most O
conspicuous O
similarities O
and O
differences O
we O
have O
found O
between O
the O
main O
modules O
of O
Duqu O
and O
Duqu O
2.0 O
. O
 
Both O
the O
two O
main O
modules O
of O
Duqu O
2.0 O
we O
have O
analyzed O
( O
" O
c7c647 O
" O
and O
" O
3f52ea O
" O
) O
has O
6 O
export O
functions O
which O
can O
be O
seen O
in O
the O
following O
figure O
. O
 
The O
new O
sample O
( O
both O
versions O
) O
is O
one O
big O
executable O
file O
that O
is O
linked O
by O
multiple O
modules O
. O
 
The O
original O
Duqu O
had O
a O
main O
module O
that O
was O
divided O
into O
two O
sub O
- O
modules O
: O
an O
outside O
layer O
and O
an O
internal O
part O
. O
 
In O
one O
version O
, O
the O
internal O
part O
was O
stored O
in O
a O
specific O
compressed O
format O
, O
while O
in O
another O
version O
, O
which O
we O
investigated O
at O
a O
Duqu O
victim O
, O
it O
was O
stored O
in O
cleartext O
in O
a O
resource O
data O
section O
of O
the O
main O
executable O
. O
 
The O
Duqu O
2.0 O
version O
we O
investigated O
is O
different O
: O
everything O
is O
incorporated O
in O
the O
main O
executable O
, O
but O
there O
are O
still O
visible O
marks O
showing O
that O
the O
malware O
is O
linked O
/ O
compiled O
from O
multiple O
different O
parts O
, O
modules O
. O
 
Some O
of B-Entity
the I-Entity
strings I-Entity
in I-Entity
Duqu I-Entity
2.0 I-Entity
are O
obfuscated B-Action
by B-Modifier
XOR O
- B-Entity
based I-Entity
encryption I-Entity
. O
 
The O
actual O
routine O
used O
is O
printed O
below O
. O
 
The O
decompiled O
version O
of O
the O
above O
assembly O
code O
can O
be O
seen O
in O
the O
following O
sample O
. O
 
The O
above O
string O
decryptor O
routine O
is O
a O
simple O
XOR O
decoder O
. O
 
It O
simply O
XORs O
consecutive O
4-byte O
blocks O
of O
the O
encrypted O
string O
buffer O
, O
given O
by O
its O
pointer O
in O
the O
first O
parameter O
of O
the O
function O
, O
with O
a O
fixed O
4-byte O
key O
( O
" O
0x86F186F1 O
" O
) O
. O
 
After O
the O
decryption O
of O
all O
consecutive O
4- O
byte O
blocks O
, O
the O
actual O
cleartext O
block O
is O
stored O
within O
the O
next O
4 O
bytes O
of O
the O
output O
buffer O
, O
pointed O
by O
parameter O
" O
a2 O
" O
. O
 
The O
decrypted O
( O
cleartext O
) O
string O
is O
terminated O
with O
a O
" O
\0 O
" O
character O
, O
and O
if O
the O
decryptor O
cycle O
reaches O
the O
end O
of O
the O
( O
cleartext O
) O
string O
, O
the O
cleartext O
string O
will O
be O
pointed O
by O
the O
address O
stored O
in O
output O
argument O
" O
a2 O
" O
. O
 
A O
closer O
look O
at O
the O
above O
C O
code O
reveals O
that O
the O
string O
decryptor O
routine O
actually O
has O
two O
parameters O
: O
" O
encrstr O
" O
and O
" O
a2 O
" O
. O
 
First O
, O
the O
decryptor O
function O
checks O
if O
the O
input O
buffer O
( O
the O
pointer O
of O
the O
encrypted O
string O
) O
points O
to O
a O
valid O
memory O
area O
( O
i.e. O
, O
it O
does O
not O
contain O
NULL O
value O
) O
. O
 
After O
that O
, O
the O
first O
4 O
bytes O
of O
the O
encrypted O
string O
buffer O
is O
XORed O
with O
the O
key O
" O
0x86F186F1 O
" O
and O
the O
result O
of O
the O
XOR O
operation O
is O
stored O
in O
variable O
" O
result O
" O
. O
 
The O
first O
DWORD O
( O
first O
4 O
bytes O
) O
of O
the O
output O
buffer O
a2 O
is O
then O
populated O
by O
this O
resulting O
value O
( O
* O
( O
_ O
DWORD O
* O
) O
a2 O
= O
result O
; O
) O
. O
 
Therefore O
, O
the O
first O
4 O
bytes O
of O
the O
output O
buffer O
will O
contain O
the O
first O
4 O
bytes O
of O
the O
cleartext O
string O
. O
 
If O
the O
first O
two O
bytes O
( O
first O
WORD O
) O
of O
the O
current O
value O
stored O
in O
variable O
" O
result O
" O
contain O
' O
\0 O
' O
characters O
, O
the O
original O
cleartext O
string O
was O
an O
empty O
string O
and O
the O
resulting O
output O
buffer O
will O
be O
populated O
by O
a O
zero O
value O
, O
stored O
on O
2 O
bytes O
. O
 
If O
the O
first O
half O
of O
the O
actual O
decrypted O
block O
( O
" O
result O
" O
variable O
) O
contains O
something O
else O
, O
the O
decryptor O
routine O
checks O
the O
second O
half O
of O
the O
block O
( O
" O
if O
( O
! O
* O
( O
_ O
WORD O
* O
) O
( O
a2 O
+ O
2 O
) O
) O
") O
. O
 
If O
this O
WORD O
value O
is O
NULL O
, O
then O
decryption O
will O
be O
ended O
and O
the O
output O
buffer O
will O
contain O
only O
one O
Unicode O
character O
with O
two O
closing O
' O
\0 O
' O
bytes O
. O
 
If O
the O
first O
decrypted O
block O
doens't O
contain O
zero O
character O
( O
generally O
this O
is O
the O
case O
) O
, O
then O
the O
decryption O
cycle O
continues O
with O
the O
next O
4-byte O
encrypted O
block O
. O
 
The O
pointer O
of O
the O
output O
buffer O
is O
incremeted O
by O
4 O
bytes O
to O
be O
able O
to O
store O
the O
next O
cleartext O
block O
( O
" O
a2 O
+ O
= O
4 O
; O
" O
) O
. O
 
After O
that O
, O
the O
following O
4-byte O
block O
of O
the O
" O
ciphertext O
" O
will O
be O
decrypted O
with O
the O
fixed O
decryption O
key O
( O
" O
0x86F186F1 O
" O
) O
. O
 
The O
result O
is O
then O
stored O
within O
the O
next O
4 O
bytes O
of O
the O
output O
buffer O
. O
 
Now O
, O
the O
output O
buffer O
contains O
2 O
blocks O
of O
the O
cleartext O
string O
. O
 
The O
condition O
of O
the O
cycle O
checks O
if O
the O
decryption O
reached O
its O
end O
by O
checking O
the O
first O
half O
of O
the O
current O
decrypted O
block O
. O
 
If O
it O
did O
not O
reached O
the O
end O
, O
then O
the O
cycle O
continues O
with O
the O
decryption O
of O
the O
next O
input O
blocks O
, O
as O
described O
above O
. O
 
Before O
the O
decryption O
of O
each O
4-byte O
" O
ciphertext O
" O
block O
, O
the O
routine O
also O
checks O
the O
second O
half O
of O
the O
previous O
cleartext O
block O
to O
decide O
whether O
the O
decoded O
string O
is O
ended O
or O
not O
. O
 
The O
original O
Duqu O
used O
a O
very O
similar O
string O
decryption O
routine O
, O
which O
we O
printed O
in O
the O
following O
figure O
below O
. O
 
We O
can O
see O
that O
this O
routine O
is O
an O
exact O
copy O
of O
the O
previously O
discussed O
routine O
( O
variable O
" O
a1 O
" O
is O
analogous O
to O
" O
encrstr O
" O
argument O
) O
. O
 
The O
only O
difference O
between O
the O
Duqu O
2.0 O
and O
Duqu O
string O
decryptor O
routines O
is O
that O
the O
XOR O
keys O
differ O
( O
in O
Duqu O
, O
the O
key O
is"0xB31FB31F O
" O
) O
. O
 
We O
can O
also O
see O
that O
the O
decompiled O
code O
of O
Duqu O
contains O
the O
decryptor O
routine O
in O
a O
more O
compact O
manner O
( O
within O
a O
" O
for O
" O
loop O
instead O
of O
a O
" O
while O
" O
) O
, O
but O
the O
two O
routines O
are O
essentially O
the O
same O
. O
 
For O
example O
, O
the O
two O
boundary O
checks O
in O
the O
Duqu O
2.0 O
routine O
( O
" O
if O
( O
! O
* O
( O
_ O
WORD O
* O
) O
( O
a2 O
+ O
2 O
) O
) O
" O
and O
" O
while O
( O
( O
_ O
WORD)result O
) O
; O
" O
) O
are O
analogous O
to O
the O
boundary O
check O
at O
the O
end O
of O
the O
" O
for O
" O
loop O
in O
the O
Duqu O
routine O
( O
" O
if O
( O
! O
( O
_ O
WORD)v4 O
|| O
! O
* O
( O
_ O
WORD O
* O
) O
( O
result O
+ O
2 O
) O
) O
") O
. O
 
Similarly O
, O
the O
increment O
operation O
within O
the O
head O
of O
the O
for O
loop O
in O
the O
Duqu O
sample O
( O
" O
result O
+ O
= O
4 O
" O
) O
is O
analogous O
to O
the O
increment O
operation O
" O
a2 O
+ O
= O
4 O
; O
" O
in O
the O
Duqu O
2.0 O
sample O
. O
 
The O
analyzed B-Entity
main I-Entity
module I-Entity
of I-Entity
Duqu I-Entity
2.0 I-Entity
and I-Entity
also I-Entity
the I-Entity
old I-Entity
Duqu I-Entity
sample I-Entity
reads B-Action
configuration O
information B-Entity
from B-Modifier
a O
special B-Entity
file I-Entity
. O
 
This O
configuration O
file O
is O
encrypted O
using O
the O
AES O
block O
cipher O
in O
CBC O
mode O
with O
a O
CTS O
- O
like O
( O
Ciphertext O
Stealing O
) O
encryption O
of O
the O
last O
two O
cleartext O
blocks O
. O
 
The O
format O
of O
the O
configuration O
file O
will O
be O
discussed O
in O
details O
in O
the O
next O
chapter O
. O
 
Before O
the O
encryption O
of O
the O
configuration O
file O
, O
an O
AES O
wrapper O
object O
is O
created O
. O
 
This O
C++ O
object O
represents O
the O
context O
( O
parameters O
) O
of O
the O
encryption O
. O
 
Therefore O
, O
it O
also O
stores O
the O
initialization O
vector O
( O
IV O
) O
of O
the O
encryption O
, O
the O
key O
of O
the O
cipher O
and O
the O
data O
to O
be O
encrypted O
. O
 
The O
structure O
of O
this O
object O
's O
class O
can O
be O
seen O
in O
the O
upper O
part O
of O
the O
next O
screenshot O
. O
 
As O
we O
can O
see O
, O
the O
allocated O
memory O
area O
of O
an O
instance O
of O
the O
" O
aeswrapper O
" O
structure O
( O
class O
) O
starts O
with O
a O
16 O
bytes O
( O
128 O
bits O
) O
IV O
value O
( O
of O
course O
, O
the O
size O
of O
the O
IV O
equals O
the O
size O
of O
an O
AES O
input O
block O
) O
. O
 
It O
is O
followed O
by O
a O
516-byte O
buffer O
( O
or O
other O
unused O
smaller O
attributes O
) O
which O
can O
store O
the O
encryption O
key O
of O
the O
AES O
cipher O
. O
 
Size O
of O
this O
encryption O
key O
can O
be O
either O
128 O
, O
192 O
or O
256 O
bits O
( O
16 O
, O
24 O
or O
32 O
bytes O
) O
. O
 
The O
last O
4 O
bytes O
of O
the O
" O
aeswrapper O
" O
structure O
contains O
the O
pointer O
to O
the O
data O
to O
be O
encrypted O
. O
 
In O
addition O
to O
the O
attributes O
( O
IV O
, O
encryption O
key O
, O
pointer O
to O
a O
data O
buffer O
) O
, O
the O
" O
aeswrapper O
" O
class O
also O
contains O
methods O
. O
 
The O
most O
important O
methods O
are O
the O
" O
encrypt O
" O
and O
" O
initialize O
" O
functions O
. O
 
As O
the O
name O
shows O
, O
the O
initialize O
method O
initializes O
the O
context O
( O
parameters O
) O
of O
the O
encryption O
, O
therefore O
it O
sets O
the O
IV O
, O
key O
and O
data O
members O
of O
the O
" O
aeswrapper O
" O
object O
. O
 
The O
IV O
is O
generated O
by O
" O
hand O
" O
, O
but O
the O
key O
is O
prepared O
from O
an O
initial O
key O
using O
the O
prepare_key O
function O
. O
 
The O
encrypt O
method O
encrypts O
the O
data O
in O
the O
modified O
CBC O
- O
CTS- O
like O
mode O
. O
 
The O
method O
uses O
an O
AES O
encryptor O
function O
. O
 
The O
nth_block O
method O
of O
the O
class O
gives O
back O
a O
pointer O
to O
the O
n O
- O
th O
block O
of O
the O
data O
to O
be O
encrypted O
. O
 
Finally O
, O
the O
" O
aeswrapper O
" O
class O
uses O
the O
last_block O
function O
to O
perform O
the O
CTS O
- O
like O
encryption O
mechanism O
at O
the O
end O
. O
 
The O
function O
gives O
back O
a O
pointer O
not O
to O
the O
last O
partial O
( O
smaller O
than O
16 O
bytes O
) O
input O
block O
, O
but O
to O
the O
last O
16 O
bytes O
of O
the O
input O
data O
buffer O
. O
 
The O
implementation O
of O
AES O
prepare_key O
and O
encrypt O
methods O
are O
presumably O
copied O
from O
function O
libraries O
. O
 
The O
figure O
above O
shows O
the O
structures O
( O
structures O
of O
class O
instances O
) O
which O
we O
identified O
and O
which O
are O
related O
to O
the O
encryption O
routine O
and O
the O
AES O
initialization O
, O
and O
the O
putative O
attributes O
of O
these O
structures O
( O
classes O
) O
. O
 
Using O
these O
structures O
, O
the O
disassembled O
code O
can O
be O
more O
readable O
. O
 
There O
is O
another O
structure O
in O
addition O
to O
the O
" O
aeswrapper O
" O
class O
called O
" O
aes O
" O
on O
the O
screenshot O
above O
. O
 
An O
instance O
of O
this O
class O
represents O
an O
AES O
encryptor O
object O
. O
 
It O
has O
probably O
3 O
attributes O
: O
key_schedule O
, O
precomputed O
and O
iteration_count O
. O
 
In O
the O
following O
table O
, O
we O
can O
see O
the O
AES O
initialization O
routine O
( O
of O
the O
configuration O
file O
encryption O
) O
of O
the O
old O
Duqu O
( O
on O
the O
left O
) O
and O
the O
new O
Duqu O
2.0 O
sample O
( O
on O
the O
right O
) O
at O
assembly O
code O
level O
. O
 
The O
decompiled O
code O
of O
the O
initialization O
function O
( O
for O
both O
malware O
samples O
) O
can O
be O
seen O
in O
figure O
Sample O
6 O
. O
 
The O
AES O
initialization O
function O
initializes O
the O
mentioned O
" O
aeswrapper O
" O
object O
, O
it O
sets O
the O
data O
buffer O
, O
prepares O
the O
encryption O
key O
, O
and O
finally O
, O
generates O
the O
IV O
based O
on O
the O
magic O
constant O
. O
 
Duqu O
" O
netp O
" O
routine O
Duqu O
2.0 O
" O
c7c64 O
" O
routine O
In O
both O
cases O
, O
the O
highlighted O
part O
of O
the O
assembly O
code O
corresponds O
to O
the O
highlighted O
part O
of O
the O
initialization O
routines O
in O
the O
decompiled O
versions O
of O
the O
code O
, O
which O
can O
be O
seen O
in O
figure O
Sample O
6 O
. O
 
The O
only O
difference O
between O
the O
highlighted O
parts O
is O
the O
values O
of O
the O
magic O
constants O
( O
" O
0xDEADBABE O
" O
vs. O
 
" O
0x248561EF O
" O
) O
which O
are O
used O
for O
the O
generation O
of O
the O
128-bit O
initialization O
vectors O
. O
 
The O
mentioned O
AES O
initialization O
routines O
( O
and O
also O
the O
common O
encryption O
function O
) O
will O
be O
discussed O
later O
in O
this O
section O
in O
more O
details O
. O
 
We O
also O
reverse O
engineered O
the O
encryption O
routine O
used O
by O
Duqu O
2.0 O
, O
which O
is O
illustrated O
in O
the O
following O
block O
diagram O
. O
 
With O
the O
exception O
of O
the O
last O
two O
input O
blocks O
, O
consecutive O
blocks O
of O
the O
cleartext O
data O
are O
encrypted O
with O
the O
AES O
encryption O
algorithm O
in O
CBC O
mode O
. O
 
Accordingly O
, O
the O
first O
block O
of O
the O
input O
data O
( O
" O
P[0 O
] O
" O
) O
is O
XORed O
with O
a O
fixed O
initialization O
vector O
( O
named O
as O
" O
Fixed O
IV O
" O
in O
the O
figure O
above O
) O
. O
 
This O
128-bit O
initialization O
vector O
( O
IV O
) O
differs O
between O
the O
old O
Duqu O
and O
the O
new O
Duqu O
2.0 O
samples O
. O
 
The O
value O
of O
this O
IV O
is O
generated O
from O
a O
magic O
constant O
, O
as O
it O
can O
be O
seen O
in O
the O
highlighted O
parts O
of O
the O
previous O
assembly O
code O
. O
 
As O
this O
magic O
constant O
is O
different O
in O
the O
old O
and O
new O
samples O
, O
the O
generated O
IV O
will O
also O
be O
different O
. O
 
The O
result O
of O
the O
previously O
mentioned O
XOR O
operation O
gives O
the O
first O
input O
block O
of O
the O
AES O
encryption O
algorithm O
( O
" O
AES-256 O
" O
is O
in O
use O
) O
. O
 
The O
number O
256 O
means O
that O
the O
AES O
algorithm O
has O
256-bit O
key O
size O
. O
 
The O
block O
size O
of O
the O
AES O
cipher O
is O
constant O
128 O
bits O
( O
16 O
bytes O
) O
. O
 
" O
E[0 O
] O
" O
is O
the O
first O
output O
of O
the O
block O
cipher O
, O
so O
it O
will O
be O
the O
first O
encrypted O
block O
( O
" O
F[0 O
] O
" O
) O
. O
 
Output O
of O
the O
block O
cipher O
( O
" O
E[0 O
] O
" O
) O
is O
then O
XORed O
with O
the O
second O
input O
block O
( O
" O
P[1 O
] O
" O
) O
, O
and O
the O
resulting O
block O
will O
be O
encrypted O
with O
AES-256 O
. O
 
This O
procedure O
continues O
until O
the O
encryption O
of O
the O
last O
but O
first O
block O
of O
the O
cleartext O
data O
. O
 
If O
the O
size O
of O
the O
input O
data O
is O
an O
integer O
multiple O
of O
the O
block O
size O
of O
AES O
( O
i.e. O
, O
128 O
bits O
) O
, O
then O
the O
remaining O
last O
two O
blocks O
of O
the O
cleartext O
are O
encrypted O
in O
the O
same O
manner O
as O
the O
previous O
input O
blocks O
. O
 
So O
, O
in O
this O
case O
, O
the O
whole O
encryption O
routine O
matches O
a O
simple O
CBC O
mode O
encryption O
. O
 
However O
, O
if O
the O
size O
of O
the O
input O
data O
is O
not O
an O
exact O
multiple O
of O
the O
AES O
block O
size O
, O
the O
last O
partial O
block O
of O
the O
input O
data O
needs O
padding O
to O
be O
completed O
to O
a O
full O
block O
. O
 
In O
case O
of O
Duqu O
2.0 O
, O
the O
developers O
of O
the O
malware O
did O
n't O
use O
padding O
in O
a O
traditional O
way O
. O
 
Instead O
, O
they O
use O
a O
CTS O
- O
like O
( O
Ciphertext O
Stealing O
) O
method O
. O
 
The O
essence O
of O
the O
method O
used O
by O
the O
encryption O
routine O
is O
that O
a O
part O
of O
the O
last O
but O
first O
block O
of O
the O
input O
data O
is O
encrypted O
twice O
using O
AES O
. O
 
The O
last O
but O
first O
block O
( O
" O
P[n-1 O
] O
" O
) O
of O
the O
cleartext O
data O
is O
XORed O
with O
the O
previous O
ciphertext O
block O
( O
" O
E[n-2 O
] O
" O
) O
and O
encrypted O
with O
AES-256 O
as O
previously O
. O
 
The O
result O
of O
this O
operation O
is O
the O
" O
E[n-1 O
] O
" O
output O
block O
. O
 
The O
" O
E[n-1 O
] O
" O
output O
block O
wo O
n't O
be O
directly O
used O
as O
the O
( O
n-1)st O
ciphertext O
block O
. O
 
Instead O
, O
the O
output O
" O
E[n-1 O
] O
" O
is O
splitted O
into O
two O
distinct O
parts O
: O
" O
F[n-1 O
] O
" O
and O
another O
part O
which O
is O
then O
fed O
into O
the O
AES O
encryptor O
again O
. O
 
The O
last O
cleartext O
partial O
block O
( O
" O
P[n O
] O
" O
) O
– O
which O
has O
size O
less O
than O
16 O
bytes O
– O
is O
completed O
from O
its O
beginning O
to O
get O
a O
full O
AES O
input O
block O
. O
 
The O
data O
used O
for O
completing O
the O
last O
partial O
block O
is O
taken O
from O
the O
end O
of O
the O
previous O
AES O
output O
block O
( O
" O
E[n-1 O
] O
" O
) O
. O
 
The O
resulting O
block O
will O
be O
fed O
into O
the O
AES-256 O
cipher O
in O
the O
last O
step O
of O
the O
encryption O
process O
. O
 
The O
output O
of O
the O
last O
invocation O
of O
the O
AES O
cipher O
will O
be O
the O
last O
ciphertext O
block O
( O
" O
F[n O
] O
" O
) O
. O
 
The O
output O
of O
the O
last O
but O
first O
invocation O
of O
the O
AES O
encryptor O
( O
" O
E[n-1 O
] O
" O
) O
is O
split O
into O
two O
parts O
, O
and O
the O
first O
part O
of O
size O
size_of_the_last_cleartext_block O
will O
be O
the O
( O
n-1)st O
ciphertext O
block O
( O
" O
F[n- O
1 O
] O
" O
) O
. O
 
The O
old O
Duqu O
samples O
used O
exactly O
the O
same O
encryption O
method O
. O
 
The O
decompiled O
code O
of O
the O
AES O
encryptor O
of O
Duqu O
can O
be O
seen O
in O
the O
following O
sample O
, O
and O
one O
can O
see O
that O
this O
code O
implements O
the O
method O
we O
have O
just O
explained O
and O
illustrated O
in O
the O
block O
diagram O
of O
Figure O
8 O
. O
 
The O
next O
table O
compares O
the O
AES O
initialization O
routines O
of O
the O
old O
Duqu O
sample O
( O
upper O
part O
of O
the O
table O
) O
and O
the O
main O
module O
of O
Duqu O
2.0 O
( O
lower O
part O
of O
the O
table O
) O
. O
 
First O
, O
the O
initialization O
routine O
copies O
the O
pointer O
of O
the O
input O
data O
buffer O
into O
the O
" O
data O
" O
member O
of O
the O
" O
aeswrapper O
" O
object O
. O
 
The O
routine O
takes O
this O
pointer O
as O
its O
second O
parameter O
. O
 
The O
first O
parameter O
is O
the O
pointer O
( O
reference O
) O
of O
the O
object O
instance O
, O
since O
in O
C++ O
, O
the O
first O
( O
hidden O
) O
parameter O
of O
a O
( O
non O
- O
static O
) O
class O
method O
is O
always O
the O
pointer O
of O
the O
object O
, O
or O
in O
other O
words O
, O
the O
" O
this O
" O
pointer O
. O
 
In O
case O
of O
Duqu O
2.0 O
, O
the O
routine O
has O
a O
third O
parameter O
, O
the O
pointer O
to O
the O
buffer O
containing O
the O
key O
. O
 
After O
that O
, O
the O
content O
of O
the O
" O
key O
" O
buffer O
( O
which O
is O
a O
global O
buffer O
in O
the O
first O
case O
) O
is O
copied O
into O
the O
local O
" O
key O
_ O
" O
buffer O
in O
both O
cases O
. O
 
Then O
the O
prepare_key O
method O
of O
the O
AES O
object O
prepares O
the O
final O
encryption O
key O
based O
on O
this O
key O
, O
and O
feeds O
it O
into O
the O
" O
aeswrapper O
" O
object O
. O
 
Invocation O
of O
the O
prepare_key O
method O
can O
also O
be O
seen O
in O
the O
assembly O
view O
( O
see O
Sample O
4 O
. O
) O
, O
the O
method O
is O
referred O
by O
the O
name O
AES1_sub_2F9B1 O
in O
case O
of O
Duqu O
and O
AES_1_sub_1001690A O
in O
case O
of O
Duqu O
2.0 O
. O
 
In O
the O
Duqu O
2.0 O
case O
, O
the O
function O
has O
one O
more O
parameter O
, O
as O
this O
can O
also O
be O
seen O
in O
the O
assembly O
view O
, O
and O
the O
length O
of O
the O
AES O
key O
is O
chosen O
as O
256 O
bits O
. O
 
Finally O
, O
the O
remaining O
part O
of O
the O
code O
initializes O
the O
IV O
member O
of O
" O
aeswrapper O
" O
object O
. O
 
Every O
byte O
of O
the O
IV O
is O
generated O
by O
XORing O
the O
index O
of O
the O
actual O
byte O
with O
a O
magic O
constant O
( O
" O
0xDEADBABE O
" O
and O
" O
0x248561EF O
" O
, O
respectively O
, O
in O
the O
two O
cases O
) O
. O
 
Byte O
index O
starts O
from O
zero O
. O
 
As O
we O
can O
see O
, O
there O
are O
only O
three O
small O
differences O
between O
the O
routines O
: O
the O
magic O
constants O
used O
by O
the O
IV O
generation O
, O
the O
fact O
that O
in O
Duqu O
the O
key O
is O
a O
constant O
global O
variable O
with O
fixed O
value O
while O
in O
Duqu O
2.0 O
it O
is O
an O
argument O
of O
the O
initialization O
function O
, O
and O
finally O
, O
the O
possible O
length O
of O
the O
key O
. O
 
In O
case O
of O
Duqu O
, O
the O
prepare_key O
function O
assumes O
that O
the O
key O
is O
always O
256 O
bits O
, O
while O
in O
case O
of O
Duqu O
2.0 O
, O
the O
prepare_key O
function O
takes O
the O
key O
length O
as O
an O
argument O
. O
 
Key O
length O
can O
be O
128 O
, O
192 O
or O
256 O
bits O
. O
 
Under O
the O
encryption O
layer O
( O
which O
is O
identical O
in O
the O
new O
and O
old O
samples O
as O
described O
in O
the O
previous O
section O
) O
, O
the O
configuration O
file O
format O
of O
the O
new O
Duqu O
2.0 O
samples O
is O
very O
similar O
to O
the O
old O
Duqu O
config O
file O
format O
. O
 
For O
an O
overview O
, O
see O
Figure O
5 O
below O
. O
 
The O
format O
is O
designed O
to O
hold O
key O
- O
value O
pairs O
. O
 
The O
keys O
are O
always O
4-byte O
long O
, O
and O
the O
values O
can O
be O
of O
arbitrary O
size O
. O
 
We O
believe O
that O
the O
keys O
are O
timestamps O
and O
the O
values O
are O
configuration O
entries O
, O
although O
the O
file O
format O
could O
hold O
any O
other O
similarly O
structured O
information O
( O
e.g. O
 
configurations O
) O
. O
 
The O
old O
file O
format O
begins O
with O
4 O
bytes O
whose O
value O
is O
undefined O
. O
 
In O
the O
serialization O
process O
, O
it O
is O
read O
from O
an O
uninitialized O
buffer O
, O
and O
it O
is O
ignored O
in O
the O
deserialization O
process O
. O
 
The O
new O
file O
format O
does O
not O
have O
such O
a O
beginning O
byte O
sequence O
. O
 
The O
main O
part O
of O
the O
file O
format O
is O
surrounded O
by O
4 O
signature O
bytes O
at O
the O
beginning O
and O
at O
the O
end O
. O
 
The O
byte O
sequence O
in O
the O
old O
Duqu O
file O
format O
is O
0x839172FF O
, O
and O
in O
the O
new O
Duqu O
2.0 O
version O
, O
it O
is O
0x7749CB4D. O
 
In O
both O
cases O
, O
the O
next O
integer O
indicates O
the O
number O
of O
entries O
, O
followed O
by O
the O
entries O
themselves O
. O
 
Each O
entry O
begins O
with O
a O
4-byte O
key O
, O
and O
then O
the O
value O
. O
 
In O
the O
new O
format O
, O
the O
value O
always O
begins O
with O
13 O
bytes O
( O
that O
can O
be O
logically O
divided O
into O
four O
4 O
byte O
integers O
and O
a O
1 O
byte O
value O
: O
4 O
+ O
4 O
+ O
1 O
+ O
4 O
+ O
4 O
) O
, O
but O
in O
the O
old O
format O
, O
this O
is O
missing O
. O
 
Furthermore O
, O
the O
value O
contains O
a O
variable O
size O
part O
in O
both O
formats O
. O
 
This O
is O
a O
length O
prefixed O
buffer O
that O
can O
hold O
arbitrary O
data O
. O
 
In O
essence O
, O
the O
only O
difference O
between O
the O
Duqu O
and O
the O
Duqu O
2.0 O
config O
file O
formats O
is O
the O
presence O
of O
the O
undefined O
4 O
bytes O
at O
the O
beginning O
of O
the O
file O
in O
the O
old O
version O
, O
and O
the O
presence O
of O
the O
13 O
additional O
value O
bytes O
in O
the O
new O
version O
. O
 
We O
've O
identified O
a B-Entity
characteristic I-Entity
logging I-Entity
function I-Entity
that O
is O
present O
in O
both O
Duqu O
and O
Duqu O
2.0 O
, O
and O
is B-Action
used I-Action
extensively O
in B-Modifier
the O
networking B-Entity
( I-Entity
mainly I-Entity
HTTP I-Entity
handling I-Entity
) I-Entity
part I-Entity
of I-Entity
the I-Entity
code I-Entity
. O
 
The O
logging O
function O
itself O
is O
identical O
, O
and O
the O
data O
structure O
used O
for O
storing O
log O
entries O
is O
very O
similar O
. O
 
The O
Duqu O
version O
of O
the O
data O
structure O
has O
embedded O
function O
pointers O
, O
while O
the O
Duqu O
2.0 O
version O
uses O
a O
virtual O
function O
table O
like O
structure O
. O
 
The O
main O
difference O
from O
a O
C++ O
virtual O
function O
table O
is O
that O
the O
pointer O
to O
the O
table O
is O
the O
last O
field O
of O
the O
associated O
structure O
instead O
of O
the O
first O
field O
( O
see O
Figure O
6 O
) O
. O
 
In O
general O
, O
change O
in O
the O
coding O
style O
can O
be O
seen O
all O
over O
the O
code O
. O
 
While O
Duqu O
uses O
object O
oriented O
style O
that O
is O
similar O
, O
but O
not O
identical O
to O
what O
C++ O
compilers O
do O
, O
Duqu O
2.0 O
moved O
mainly O
to O
" O
real O
" O
C++ O
, O
but O
there O
are O
still O
deviations O
from O
the O
standard O
C++ O
style O
( O
like O
the O
previously O
function O
table O
) O
. O
 
Both O
the O
Duqu O
and O
Duqu O
2.0 O
avoids O
storing O
the O
messages O
logged O
through O
this O
function O
. O
 
In O
both O
codebase O
, O
a O
" O
handle_log_entry O
" O
function O
is O
called O
after O
creating O
the O
log O
entry O
structure O
, O
but O
this O
function O
throws O
the O
object O
away O
( O
frees O
the O
memory O
) O
and O
does O
not O
print O
or O
save O
it O
. O
 
The O
authors O
probably O
used O
C O
/ O
C++ O
macros O
to O
avoid O
detailed O
logging O
in O
release O
builds O
, O
but O
in O
this O
case O
we O
still O
see O
the O
logging O
function O
invocation O
. O
 
In O
this O
case O
, O
the O
macro O
was O
probably O
placed O
in O
the O
function O
that O
should O
have O
printed O
the O
log O
message O
( O
handle_log_entry O
) O
, O
and O
since O
this O
is O
a O
virtual O
function O
, O
the O
compiler O
could O
not O
optimize O
out O
the O
function O
invocations O
directly O
. O
 
The O
logging O
function O
is O
called O
equal O
times O
in O
the O
Duqu O
and O
the O
Duqu O
2.0 O
samples O
, O
and O
the O
invocation O
is O
always O
very O
similar O
( O
see O
Figure O
7 O
) O
. O
 
The O
arguments O
are O
usually O
not O
strings O
describing O
the O
event O
directly O
, O
but O
4 O
byte O
magic O
numbers O
. O
 
The O
logging O
function O
is O
invoked O
equal O
times O
, O
and O
the O
magic O
numbers O
are O
almost O
always O
identical O
in O
Duqu O
and O
Duqu O
2.0 O
. O
 
The O
network O
communication O
methods O
used O
by O
Duqu O
2.0 O
are O
described O
in O
the O
following O
list O
. O
 
SocketServer1 O
. O
 
In O
export O
function O
nr1 O
, O
if O
in O
the O
config O
the O
" O
startSockServer O
" O
parameter O
is O
set O
, O
it O
will O
start O
a O
server O
accordingly O
SocketServer2 O
. O
 
Binds O
between O
ports O
17000 O
and O
17100 O
, O
can O
be O
configured O
to O
be O
client O
or O
server O
GifServer O
. O
 
With O
Custom O
HTTP O
Server O
implementation O
, O
possibly O
based O
on O
SocketServer2 O
PipeComm O
. O
 
PIPE O
or O
IPC O
communication O
, O
customizable O
network O
communication O
HttpClient O
. O
 
WinHTTP O
- O
based O
, O
simple O
client O
, O
uses O
" O
COUNTRY= O
" O
in O
cookie O
parameters O
, O
( O
standard O
HTTP O
client O
) O
Duqu O
has O
used O
a O
very O
unique O
user O
agent O
string O
when O
communicating O
over O
HTTP O
. O
 
Mozilla/5.0 O
( O
Windows O
; O
U O
; O
Windows O
NT O
6.0 O
; O
en O
- O
US O
; O
rv:1.9.2.9 O
) O
In O
contrast O
, O
Duqu O
2.0 O
chooses O
user O
agent O
string O
randomly O
from O
a O
large O
set O
of O
often O
used O
values O
listed O
in O
Sample O
7 O
. O
 
The O
following O
list O
shows O
the O
browser O
agent O
strings O
found O
in O
Duqu O
2.0 O
. O
 
Duqu O
2.0 O
uses O
more O
than O
one O
method O
to O
import O
functions O
from O
DLLs O
. O
 
One O
of O
the O
methods O
utilizes O
a O
hash O
method O
to O
represent O
function O
names O
as O
4 O
byte O
integers O
. O
 
It O
iterates O
through O
all O
importable O
function O
and O
finds O
the O
one O
whose O
function O
name O
hash O
matches O
the O
given O
hash O
. O
 
This O
hash O
function O
uses O
a O
magic O
number O
. O
 
A O
very O
similar O
import O
method O
and O
hash O
function O
is O
used O
in O
Duqu O
and O
Duqu O
2.0 O
although O
the O
magic O
numbers O
are O
different O
: O
0x86F186F1 O
and O
0xB31FB31F. O
 
Note O
that O
even O
the O
inner O
structure O
of O
the O
magic O
numbers O
are O
similar O
( O
2x2 O
bytes O
) O
. O
 
The O
malware B-Entity
can O
transmit B-Action
information B-Entity
through B-Modifier
HTTP O
traffic B-Entity
. O
 
It O
is O
most O
likely O
that O
one B-Entity
or I-Entity
more I-Entity
infected I-Entity
computers I-Entity
can O
be B-Action
proxy O
points B-Entity
towards B-Modifier
the O
attacker B-Entity
, O
meaning O
that O
other O
infected O
computers O
communicate O
with O
these O
proxies O
. O
 
These O
proxies B-Entity
can O
act B-Action
as B-Modifier
HTTP O
or B-Entity
HTTPS I-Entity
servers I-Entity
. O
 
For O
HTTPS O
, O
a O
self O
signed O
certificate O
is O
created O
by O
the O
malware O
itself O
. O
 
( O
Most O
likely O
by O
contacting O
gpl3.selfsigned.org O
) O
. O
 
The O
Common O
Name O
( O
CN O
) O
field O
seems O
to O
be O
" O
* O
" O
in O
the O
created O
certificate O
. O
 
During O
data O
transfer O
, O
the O
malware O
uses O
< O
5 O
random O
numbers>.gif O
for O
file O
name O
and O
a O
843-byte O
GIF O
file O
+ O
additional O
random O
bytes O
. O
 
The O
transmissions O
may O
be O
protected O
by O
AES O
. O
 
One O
possible O
way O
to O
detect O
such O
transmission O
( O
if O
cleartext O
traffic O
is O
somehow O
available O
) O
to O
detect O
the O
actual O
843-byte O
GIF O
file O
. O
 
For O
the O
known O
two O
samples O
, O
this O
GIF O
portion O
was O
identical O
. O
 
The O
actual O
image O
in O
hex O
dump O
is O
the O
following O
. O
 
The O
image O
itself O
is O
a O
small O
picture O
, O
basic O
color O
is O
yellow O
and O
there O
are O
some O
orange O
dots O
in O
it O
. O
 
For O
the O
main O
binary O
of O
the O
malware O
, O
we O
propose O
the O
following O
rules O
for O
detection O
. O
 
We O
've O
made O
an O
initial O
analysis O
to O
prove O
our O
claims O
that O
there O
is O
a O
strong O
connection O
between O
Duqu O
and O
Duqu O
2.0 O
malwares O
. O
 
Our O
main O
goal O
was O
to O
highlight O
the O
most O
striking O
similarities O
and O
differences O
between O
the O
samples O
. O
 
Similarities O
shows O
that O
the O
developers O
of O
Duqu O
2.0 O
have O
reused O
the O
code O
basis O
of O
the O
old O
Duqu O
specimens O
and O
the O
differences O
found O
in O
the O
binaries O
indicates O
that O
the O
developers O
of O
Duqu O
have O
modified O
their O
tools O
to O
avoid O
detections O
. O
 
[ O
CrySySDuqu O
] O
CrySyS O
, O
Duqu O
: O
A O
Stuxnet O
- O
like O
malware O
found O
in O
the O
wild O
, O
v0.93 O
( O
14/Oct/2011 O
) O
http://www.crysys.hu/publications/files/bencsathPBF11duqu.pdf O
[ O
SymantecDuqu O
] O
Symantec O
, O
W32.Duqu O
: O
The O
precursor O
to O
the O
next O
Stuxnet O
, O
Version O
1.4 O
( O
November O
23 O
, O
2011 O
) O
http://www.symantec.com/content/en/us/enterprise/media/security_response/white O
papers O
/ O
w32_duqu_the_precursor_to_the_next_stuxnet.pdf O
[ O
KasperskyDuqu O
] O
Kaspersky O
Lab O
, O
Duqu O
: O
Steal O
Everything O
, O
Kaspersky O
Lab O
's O
investigation O
- O
" O
The O
Mystery O
of O
Duqu O
" O
in O
blogs O
http://www.kaspersky.com/about/press/major_malware_outbreaks/duqu O
[ O
SymantecDossier O
] O
Symantec O
, O
W32.Stuxnet O
Dossier O
, O
Version O
1.4 O
( O
February O
2011 O
) O
http://www.symantec.com/content/en/us/enterprise/media/security_response/white O
papers O
/ O
w32_stuxnet_dossier.pdf O
[ O
KasperskyDuqu2.0 O
] O
Kaspersky O
Lab O
, O
The O
Duqu O
2.0 O
: O
Technical O
Details O
, O
Version O
: O
1.9.8 O
( O
2.June.2015 O
) O
https://securelist.com O
/ O
blog O
/ O
research/70504/the O
- O
mystery O
- O
of O
- O
duqu-2 O
- O
0-a O
- O
sophisticated- O
cyberespionage O
- O
actor O
- O
returns/ O
Questions O
and O
comments O
are O
welcome O
. O
 
The O
corresponding O
author O
is O
Dr. O
 
Boldizs O
r O
Bencs O
th O
bencsath@crysys.hu O
Laboratory O
of O
Cryptography O
and O
System O
Security O
CrySyS O
– O
http://www.crysys.hu/ O
Budapest O
University O
of O
Technology O
and O
Economics O
Department O
of O
Telecommunications O
1117 O
Magyar O
Tud O
sok O
Krt O
. O
 
2 O
. O
 
Budapest O
, O
Hungary O
GPG O
BENCSATH O
Boldizsar O
< O
boldi@crysys.hu O
> O
Key O
ID O
0x64CF6EFB O
Fingerprint O
286C O
A586 O
6311 O
36B3 O
2F94 O
B905 O
AFB7 O
C688 O
64CF O
6EFB O
 
